# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
difference=mean(control)-mean(treated)
if(paired==FALSE) {
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population)
diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- diff
}
p <- mean(all_diffs>=abs(difference))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
p <- mean(abs(all_diffs)>=abs(mean(diff_paired)))
}
}
return(p)
}
p(x,y)
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
p(x,y)
p(x,y, paired = TRUE, test = "r")
p(x,y, paired = TRUE, test = "t")
p(x,y, paired = FALSE, test = "t")
p(x,y, paired = FALSE, test = "ra")
p(x,y, paired = FALSE, test = "r")
p(x,y, paired = FALSE, test = "randomization")
p(x,y, paired = TRUE, test = "randomization")
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
print(paste(rnd_diff))
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
print(paste(rnd_diff))
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
p(x,y)
p(x,y, paired = TRUE, test = "randomization")
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
all_diffs <- vector(length = 1000)
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
print(paste(rnd_diff))
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
print(paste(rnd_diff))
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
p(x,y)
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
all_diffs <- vector(length = 1000)
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
print(paste(rnd_diff))
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
print(paste(all_diffs[3]))
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
p(x,y)
p(x,y, paired = TRUE, test = "randomization")
p(x,y, paired = TRUE, test = "randomizat")
p(x,y, paired = TRUE, test = "randomization")
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
all_diffs <- vector(length = 1000)
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
p(x,y)
p(x,y, paired = TRUE, test = "randomization")
p(x,y, paired = FALSE, test = "randomization")
p(x,y, paired = TURE, test = "randomization")
p(x,y, paired = TRUE, test = "randomization")
p(x,y, paired = TRUE, test = "randomiza")
p(x,y, paired = FALSE, test = "randomiza")
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
all_diffs <- vector(length = 1000)
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
p <- mean(all_diffs>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
x <- rnorm(n = 10, mean = 1, sd = 1)
y <- rnorm(n = 10, mean = 1.5, sd = 1)
p(x,y)
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "t")
p(x,y, T, "t")
p(x,y, F, "t")
p(x,y, T, "t")
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "randomization")
p(x,y, F, "randomization")
p(x,y, F, "randomization")
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, T, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "t")
p(x,y, T, "t")
p(x,y, T, "t")
p(x,y, T, "t")
p(x,y, F, "t")
p(x,y, F, "t")
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, T, "randomization")
p(x,y, T, "t")
p(x,y, F, "t")
p(x,y, F, "t")
p(x,y, F, "randomization")
########### R function to calculate p-value ###############
# written by @joachimgoedhart; First version on september 2020
# The input are two vectors of data (control, treated)
# The data can be either paired or unpaired
# Paired data require vectors of identical length, if FALSE a unpaired test is performed
# For n<3 no t-test is performed (return NA)
# The test is either a Welch's t-test or a randomization test
p = function(control,treated,paired=TRUE,test="randomization") {
all_diffs <- vector(length = 1000)
#Check whether input vectors have equal size, which is required for paired data
if (length(control)-length(treated)!=0) {paired <- FALSE}
# For n<3 return NA
if (length(control)<3 || length(treated)<3) {return(NA)}
####### Ordinary t-test #######
if (test!="randomization") {
result <- t.test(control, treated,paired=paired)
return((result$p.value))
}
####### Randomization test #######
if (test=="randomization" || test=="r") {
###### RANDOMIZATION FOR UNPAIRED DATA
if(paired==FALSE) {
Obs_diff=mean(control)-mean(treated)
number_controls <- length(control)
population <- c(control,treated)
number_tot <- length(population)
# Generate the Null hypothesis for unpaired data
for (i in 1:1000) {
sam <- sample(population, replace = FALSE)
rnd_diff <- mean(sam[1:number_controls])-mean(sam[(number_controls+1):number_tot])
all_diffs[i] <- rnd_diff
}
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
###### RANDOMIZATION FOR PAIRED DATA
if (paired==TRUE) {
Obs_diff <- mean(control-treated)
diff_paired <- control-treated
# Generate the Null hypothesis for paired data
for (i in 1:1000) {
#Random flipping of signs for the differences (https://www.uvm.edu/~statdhtx/StatPages/ResamplingWithR/RandomMatchedSample/RandomMatchedSampleR.html)
signs <- sample(c(1,-1),length(control), replace = T)
all_diffs[i]=mean(diff_paired*signs)
}
p <- mean(abs(all_diffs)>=abs(Obs_diff))
}
}
return(p)
}
x <- rnorm(n = 10, mean = 1, sd = 1)
y <- rnorm(n = 10, mean = 1.5, sd = 1)
p(x,y, F, "randomization")
p(x,y, T, "randomization")
p(x,y, F, "t")
p(x,y, T, "t")
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
df <- tibble(
ID = rep(1:2, 4),
Group = c("A", "B", "A", "B","A", "B", "A", "B"),
Parameter = c("Blood", "Blood", "Height", "Height", "Waist", "Waist", "Hip", "Hip"),
Value = c(6.3, 6.0, 180, 170, 90, 102, 60, 65))
library("tidyverse", lib.loc="~/Library/R/3.6/library")
df <- tibble(
ID = rep(1:2, 4),
Group = c("A", "B", "A", "B","A", "B", "A", "B"),
Parameter = c("Blood", "Blood", "Height", "Height", "Waist", "Waist", "Hip", "Hip"),
Value = c(6.3, 6.0, 180, 170, 90, 102, 60, 65))
View(df)
df <- tibble(
id = rep(1:2, 4),
group = c("A", "B", "A", "B","A", "B", "A", "B"),
parameter = c("Blood", "Blood", "Height", "Height", "Waist", "Waist", "Hip", "Hip"),
value = c(6.3, 6.0, 180, 170, 90, 102, 60, 65))
shiny::runApp('surfdrive/Shiny-project/ggPlotteR')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
runApp('surfdrive/Shiny-project/SuperPlotsOfData')
source("../ggPlotteR/function_tidy_df.R")
setwd("~/surfdrive/Shiny-project/SuperPlotsOfData")
source("geom_flat_violin.R")
source("../ggPlotteR/function_tidy_df.R")
runApp()
runApp()
runApp('~/surfdrive/Shiny-project/PlotsOfData')
runApp()
runApp('~/surfdrive/Shiny-project/ggPlotteR')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/surfdrive/Shiny-project/ggPlotteR')
runApp()
runApp()
